                                   Java 内存模型
                                                              做成者:ZoroXing
                                                              做成日:2014/07/29

■1. 基本概念
      ▶1. 硬件的效率与一致性
          ▪ ★为了解决处理器与内存的速度矛盾，引入了基于高速缓存的存储交互模型；
          ▪ 主要问题：缓存一致性。在多处理器系统中，每个处理器都有自己的高速缓
            存，而它们又共享同一主内存；
          ▪ 内存模型：在特定的操作协议下，对特定的内存或高速缓存进行读写访问过
            程的抽象；
          ▪ ★为了使处理器内部运算单元能被充分利用，处理器可能会对输入的代码进
            行乱序执行(Out-of-Order Exe)或指令重排序(Instruction Reorder)。
      ▶2. JAVA内存模型
          ▪ ★主要定义了程序中各个变量的访问规则，即在虚拟机中将变量存储到内存
            和从内存中取出变量这样的底层细节。变量包括：
              ▷ 实例字段
              ▷ 静态字段
              ▷ 构成数组对象的元素
              ▷ 但是不包括局部变量和方法参数，因为它们不是线程共享的。
          ▪ 所有变量都存储到主内存(Main Memory)；
          ▪ 每条线程都有它自己的工作内存(Working Memory),保存该线程使用到变量
            的主内存副本拷贝；
          ▪ 线程对变量的操作都必须在工作内存中进行，不可直接操作主内存；
          ▪ 不同线程无法直接访问对方工作内存中的变量；
          ▪ 线程间变量值的传递均需要通过主内存来完成；

■2. 工作内存与主内存的交互协议
     交互协议定义了一个变量如何从主内存拷贝到工作内存，如何从工作内存同步会主
     内存的实现细节。主要通过以下8个原子的，不可再分的操作完成：
      ▪ lock （锁定）
      ▪ unlock (解锁)
      ▪ read （读取到工作内存）
      ▪ load （载入）
      ▪ use （使用）
      ▪ assign （赋值）
      ▪ store （存储）
      ▪ write （写入主内存）

■3. volatile变量的两种特性
     ▶1. 可见性
         保证此变量对所有线程可见，即：当一条线程修改了这个变量的值，新值对于
         其他线程来说是可以立即得知的；
     ▶2. 禁止了指令重排序优化。

■4. Java模型的功能
     Java内存模型是围绕着并发过程中如何处理原子性，可见性和有序性来建立的；
     ▶1. 原子性
         JMM直接保证的原子性变量操作包括：read，load，assign，use等。可以认为
         基本数据类型的访问读写是具备原子性的；
     ▶2. 可见性
         ▪ volatitle变量
         ▪ synchronized块
           对一个变量执行unlock前，必须先把此变量同步回主内存中；
         ▪ final变量
           final变量一旦在构造器中初始化完成，并且构造器没有把“this”引用传递
           出去。
           ★this引用逃逸，例如：在建构函数中创建了一个匿名类，然后发布了这个
           匿名类
           --------------------------------------------------------------------
           public class ThisEscape {
                 private final int num;

                 public ThisEscape() {
                   new Runnable(){
                      public void run() {
                         doSomething();
                      }
                   }.run();
                   num = 42;
                 }

                 private void doSomething() {
                     if (num != 42) {
                       System.out.println("Race condition detected");
                     } else {
                       System.out.println("Sucess!");
                     }
                 }
           }
           --------------------------------------------------------------------
           运行结果会出现[Race condition detected]
     ▶3. 有序性
         ▪ 在线程内部观察，所有的操作都是有序的；
           串行语义
         ▪ 在线程外部观察，所有的操作都会无序的；
           无序是指令重排序和工作内存和主内存的同步延迟的现象；volatitle和synchronized
           保证线程之间操作的有序性：
           ▷ volatitle通过禁止指令重排序；
           ▷ synchronized 通过一个变量在同一个时刻只允许一个线程对其加锁。

■4. 先行发生原则(Happens-before)
     为了保证Java内存模型的有序性：Java语言中有一个“先行发生”的原则（天然的）
     ▶ 传递性
     ▶ 程序次序规则（单个线程中）
     ▶ 管程锁定规则：unlock 先行发生与后面对同一个锁的lock操作；
     ▶ volatitle变量规则：对volatitle变量的写先行发生于后面对这个变量的读；
     ▶ 线程启动，终止，中断规则
     ▶ 对象终结规则，构造函数结束先行发生于他的finalize方法的开始。

以上。
